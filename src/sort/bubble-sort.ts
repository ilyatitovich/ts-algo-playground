// Пузырьковая сортировка (Bubble Sort)
export function bubbleSort(arr: number[]): number[] {
  let swapped: boolean; // Флаг, показывающий, были ли произведены обмены

  // Выполняем сортировку, пока есть обмены
  do {
    swapped = false; // Каждый проход начинается с флага, равного false

    // Проходим по массиву и сравниваем соседние элементы
    for (let i = 0; i < arr.length - 1; i++) {
      // Если текущий элемент больше следующего, меняем их местами
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1); // Вызываем функцию для обмена
        swapped = true; // Отмечаем, что был произведён обмен
      }
    }
  } while (swapped); // Повторяем, пока на проходе были обмены

  return arr; // Возвращаем отсортированный массив
}

// Функция для обмена элементов массива
function swap(arr: number[], i: number, j: number): void {
  const tmp = arr[i]; // Сохраняем значение элемента i
  arr[i] = arr[j]; // Меняем местами элементы i и j
  arr[j] = tmp; // Записываем сохранённое значение в позицию j
}

/*
Разбор алгоритма:

Инициализация флага swapped:
- В начале флаг swapped устанавливается в false. Это флаг будет указывать, были ли произведены обмены элементов в текущем проходе.

Основной цикл:
- Используется цикл do...while, чтобы продолжать сортировать массив, пока есть обмены.
- Внутри цикла устанавливается флаг swapped = false, что сигнализирует о том, что в начале текущего прохода обменов не было.

Вложенный цикл:
- Мы проходим по массиву и сравниваем соседние элементы.
- Если элемент слева больше элемента справа (arr[i] > arr[i + 1]), то выполняем обмен элементов с помощью функции swap().
- После выполнения обмена, флаг swapped устанавливается в true, что значит, что был сделан хотя бы один обмен в этом проходе.

Условие завершения:
- Если на каком-то проходе не было обменов (то есть массив отсортирован), флаг swapped остаётся false, и сортировка завершится.

Функция обмена:
- Функция swap() меняет местами два элемента массива: один на позиции i и другой на позиции j.

Сложность:
- В худшем случае (когда массив полностью отсортирован в обратном порядке) алгоритм имеет сложность O(n^2), так как каждый элемент массива будет несколько раз сравниваться и меняться местами.
- В лучшем случае (когда массив уже отсортирован) сложность O(n), так как мы не будем производить обмены в первом проходе, и цикл завершится на первом шаге.
- В среднем случае сложность также составляет O(n^2).

Плюсы и минусы:

Плюсы:
- Простой для реализации.
- Хорошо работает на маленьких массивах.

Минусы:
- Малоэффективен для больших массивов, так как имеет квадратичную сложность в худшем случае.
- Для больших данных лучше использовать более эффективные алгоритмы сортировки, такие как быстрая сортировка или сортировка слиянием.

*/
