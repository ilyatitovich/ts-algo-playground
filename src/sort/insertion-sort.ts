// Сортировка вставками (Insertion Sort)
function insertionSort(arr: number[]): number[] {
  // Проходим по массиву начиная с индекса 1
  for (let i = 1; i < arr.length; i++) {
    // Находим индекс, куда нужно вставить текущий элемент
    const insertionIndex = findInsertionIndex(arr, i);
    // Сдвигаем элементы и вставляем текущий элемент на нужное место
    shiftElements(arr, insertionIndex, i);
  }

  // Возвращаем отсортированный массив
  return arr;
}

// Функция для нахождения места вставки для текущего элемента
function findInsertionIndex(arr: number[], i: number): number {
  // Ищем индекс, до которого текущий элемент меньше всех элементов
  for (let j = 0; j < i; j++) {
    if (arr[i] < arr[j]) {
      return j; // Возвращаем индекс, куда нужно вставить текущий элемент
    }
  }

  // Если элемент больше всех предыдущих, он остаётся на текущем месте
  return i;
}

// Функция для сдвига элементов массива
function shiftElements(arr: number[], insertionIndex: number, i: number): void {
  const value = arr[i]; // Сохраняем значение текущего элемента

  // Сдвигаем все элементы между insertionIndex и i вправо
  for (let j = i; j > insertionIndex; j--) {
    arr[j] = arr[j - 1]; // Перемещаем элемент в следующую позицию
  }

  // Вставляем текущий элемент в нужное место
  arr[insertionIndex] = value;
}

/*
Разбор алгоритма:

Основной цикл (insertionSort):
- Алгоритм начинается с индекса 1, потому что элемент на позиции 0 уже считается отсортированным.
- Для каждого элемента на позиции i вызывается функция findInsertionIndex(), чтобы найти индекс, на который нужно вставить этот элемент.
- Затем вызывается функция shiftElements(), чтобы сдвигать элементы массива вправо и вставить текущий элемент на правильную позицию.

Функция findInsertionIndex():
- Эта функция ищет правильное место для текущего элемента, сравнивая его с элементами до него (от 0 до i-1).
- Как только находит элемент, который больше текущего, возвращает индекс этого элемента, который будет индеком вставки.

Функция shiftElements():
- В этой функции сначала сохраняем значение текущего элемента.
- Затем сдвигаем все элементы между позицией вставки и текущей позицией вправо (перемещаем их на одну позицию).
- Наконец, вставляем текущий элемент на нужное место.

Сложность:
- В худшем случае (когда массив отсортирован в обратном порядке), сложность O(n^2), так как для каждого элемента требуется пройти все предыдущие элементы.
- В лучшем случае (когда массив уже отсортирован), сложность O(n), так как каждый элемент будет сразу вставляться на свою позицию без необходимости сдвигать элементы.
- В среднем случае сложность также составляет O(n^2).

Плюсы и минусы:

Плюсы:
- Простота реализации.
- Хорошо работает для небольших массивов или почти отсортированных данных.

Минусы:
- Для больших массивов имеет квадратичную сложность, поэтому неэффективен для сортировки больших объёмов данных.
- Для больших массивов предпочтительнее использовать более эффективные алгоритмы, такие как быстрая сортировка или сортировка слиянием.
*/
