# Binary Search Tree (BST)

## Описание

Бинарное дерево поиска (BST) — это упорядоченная структура данных, которая используется для хранения элементов в иерархическом порядке. Каждый узел в BST имеет максимум два потомка: левый и правый. Основное правило BST:

- Значения в левом поддереве меньше значения в текущем узле.
- Значения в правом поддереве больше значения в текущем узле.

## Основные операции

### Вставка (Insert)

При вставке нового элемента в BST мы начинаем с корневого узла и рекурсивно спускаемся влево или вправо в зависимости от значения нового элемента, пока не находим пустое место для вставки.

**Сложность**: O(log n) в среднем, O(n) в худшем случае (если дерево вырожденное).

### Поиск (Search)

Для поиска элемента мы сравниваем его значение с корневым узлом. Если значение меньше, идём в левое поддерево, если больше — в правое, пока не найдём элемент или не достигнем конца.

**Сложность**: O(log n) в среднем, O(n) в худшем случае.

### Удаление (Delete)

Удаление элемента в BST имеет три случая:

1. Узел — лист (без детей) → просто удаляем.
2. Узел имеет одного потомка → заменяем узел его потомком.
3. Узел имеет двух потомков → находим наименьший элемент в правом поддереве (inorder successor) и заменяем им удаляемый узел.

**Сложность**: O(log n) в среднем, O(n) в худшем случае.

### Обход дерева (Traversal)

1. **Inorder (Лево-Корень-Право)** – возвращает элементы в отсортированном порядке.
2. **Preorder (Корень-Лево-Право)** – используется для копирования дерева.
3. **Postorder (Лево-Право-Корень)** – полезно для удаления дерева.

## Применение BST

- Хранение отсортированных данных для быстрого поиска.
- Реализация множества (Set) и ассоциативного массива (Map).
- Алгоритмы поиска ближайшего соседа (например, в географических информационных системах).
- Индексы баз данных.

## Пример реализации на TypeScript

```typescript
class TreeNode<T> {
    value: T;
    left: TreeNode<T> | null = null;
    right: TreeNode<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }
}

class BinarySearchTree<T> {
    root: TreeNode<T> | null = null;

    insert(value: T) {
        const newNode = new TreeNode(value);
        if (!this.root) {
            this.root = newNode;
            return;
        }
        let current: TreeNode<T> = this.root;
        while (true) {
            if (value < current.value) {
                if (!current.left) {
                    current.left = newNode;
                    return;
                }
                current = current.left;
            } else {
                if (!current.right) {
                    current.right = newNode;
                    return;
                }
                current = current.right;
            }
        }
    }

    search(value: T): boolean {
        let current = this.root;
        while (current) {
            if (value === current.value) return true;
            current = value < current.value ? current.left : current.right;
        }
        return false;
    }
}

const bst = new BinarySearchTree<number>();
bst.insert(10);
bst.insert(5);
bst.insert(15);
console.log(bst.search(10)); // true
console.log(bst.search(20)); // false
```

## Заключение

Бинарное дерево поиска — эффективная структура данных для хранения и быстрого поиска элементов. Однако в худшем случае оно может выродиться в связанный список, поэтому на практике часто используются самобалансирующиеся деревья, такие как AVL-дерево или Красно-черное дерево.
