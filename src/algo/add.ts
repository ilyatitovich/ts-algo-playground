/*
Сложение
Напишите функцию, которая выполняет сложение посредством каррирования.


Решение:
Для реализации функции сложения через каррирование, нужно,
чтобы функция add могла принимать число и возвращать новую функцию,
которая также может принимать число, и так далее, пока не будет вызвана
без аргументов (или с пустым вызовом ()), что сигнализирует о завершении сложения.
*/

type StepFn = (val: number) => number | StepFn;

function add(val?: number): number | StepFn {
  // Если функция вызвана без аргументов, возвращаем 0
  if (val === undefined) {
    return 0;
  }

  // Внутренняя функция, которая накапливает сумму
  const innerAdd: StepFn = (nextVal?: number): number | StepFn => {
    // Если вызов без аргументов, возвращаем накопленную сумму
    if (nextVal === undefined) {
      return val;
    }
    // Иначе рекурсивно вызываем innerAdd с новой суммой
    return add(val + nextVal);
  };

  return innerAdd;
}

export default add;

/*
Объяснение:

1. База каррирования:
  Если функция add вызывается без аргументов (add()),
  она возвращает 0, что соответствует пустой сумме.

2. Накопление суммы:
  Если передано число (add(1)), функция возвращает новую функцию innerAdd,
  которая ожидает следующее число или завершение вызова.

3. Рекурсия:
  Каждый вызов innerAdd либо добавляет переданное число к
  текущей сумме и возвращает новую функцию, либо завершает вычисление,
  если вызов происходит без аргументов.

4. Завершение:
  Когда функция вызывается без аргументов (()), она возвращает накопленную сумму.

*/
